#include <Arduino.h>
#include <HardwareSerial.h>
#include <SoftwareSerial.h>
#include <TimerOne.h> // подключаем библиотеку TimerOne для задействования функций Таймера1 

#include <fft.h>                       // подключаем библиотеку для разложения сигнала в спектр (по алгоритму "Быстрого преобразования Фурье"),  
                                       // скачиваем ее отсюда и устанавливаем: https://www.dropbox.com/s/vw46osetrwgft43/FFT.zip
#define num 256                        // зададим число оцифрованных значений сигнала ЭЭГ, которое будет отправлено в функцию для разложения в спектр

#define SERVO_PIN 9                             // определим номер вывода Arduino, к которому подключается мотор
#define arrSize 32                           // размер массива оцифрованных значений для поиска в нем максимума и минимума сигнала
#define TRESHOLD 150                        // порог срабатывания мотора (может требовать подстройки)

double sData_left = 0;                            // амплитуда размаха электромиографического сигнала
double sData_right = 0;
int val_emg_left[arrSize];                            // массив для хранения оцифрованных значений ЭМГ-сигнала
int val_emg_right[arrSize];
int i = 0;                                   // переменная-счетчик 
int emg_l = 0;
int emg_r = 0;                                 // переменная для хранения оцифрованного значения сигнала  
int maxV_l = 0, minV_l = 0;                      // переменные для хранения максимального и минимального значений ЭМГ-сигнала в массиве val[] 
int maxV_r = 0, minV_r = 0;

float threshold = 11;                  // порог срабатывания светодиода или мотора красного пропеллера (может требовать подстройки под конкретного человека)
int8_t im[num], data[num];             // массивы для накопления данных                            // переменная-счетчик 
int val = 0;
byte sped = 0;
bool fail = false;                     // логическая (булева) переменная, значение которой равно ИСТИНА при высоком уровне помех
float specter = 0;                     // переменная для хранения текущего значения спектра
float specter_old = 0;                 // переменная для хранения предыдущего значения спектра
int test = 0;

SoftwareSerial serial1(12, 13);         //настраиваем объект класса программного последовательного порта на отправку данных

int mas_data[3] = {1, 1, 0};                  //массив для отправки данных данных [0] = левый, [1] - правый, [2] - мотор

void sendData() {
////////////////левая рука
  
  emg_l = analogRead(A0);                       // записываем в переменную emg оцифрованное значение сигнала с ножки А0 на Arduino.
  emg_r = analogRead(A1);                                       
  val_emg_left[i] = map(emg_l, 0, 1023, 0, 255);         // записываем в элемент массива val[i] переменную emg, предварительно отнормированную на диапазон значений от 0 до 255,
  val_emg_right[i] = map(emg_r, 0, 1023, 0, 255);                                            // см. описание команды map:  http://arduino.ru/Reference/Map 
  i++;                                        // инкрементируем (увеличиваем на 1) значение переменной-счетчика
  
  if (i == arrSize) {                         // если полностью заполнили массив
    i = 0;                                    // сбрасываем значение переменной-счетчика в 0
    // Ищем максимальное и минимальное значение ЭМГ-сигнала в массиве val[] 
    for (int k = 0; k < arrSize; k++) {       // в цикле for c переменной-итератором k перебираем элементы массива val[]
      //left sensor
      if (val_emg_left[k] > maxV_l)                      // если элемент массива val[k] больше, чем значение ранее записанное в переменной для хранения максимумов maxV,
        maxV_l = val_emg_left[k];                        // обновляем значение maxV
      else if(val_emg_left[k] < minV_l)                      // если же элемент массива val[k] меньше, чем значение ранее записанное в переменной для хранения минимумов minV,
        minV_l = val_emg_left[k];                        // обновляем значение minV
      //right sensor
      if (val_emg_right[k] > maxV_r)                      // если элемент массива val[k] больше, чем значение ранее записанное в переменной для хранения максимумов maxV,
        maxV_r = val_emg_right[k];                        // обновляем значение maxV
      else if(val_emg_right[k] < minV_r)                      // если же элемент массива val[k] меньше, чем значение ранее записанное в переменной для хранения минимумов minV,
        minV_r = val_emg_right[k];   
    }
    //sData =  0.4*sData + 0.6*(maxV - minV); // чтобы срабатывание мотора было более плавным, раскомментируйте эту строку и закомментируйте следующую. Теория: https://ru.wikipedia.org/wiki/Экспоненциальное_сглаживание 
    sData_left = maxV_l - minV_l;                      // определяем максимальный размах сигнала   
    Serial.println(sData_left);
    sData_right = maxV_r - minV_r;
    maxV_l = 0;                                 // обнуляем значение переменной maxV, в которой хранится значение максимального элемента массива val[] 
    minV_l = 0;                                 // обнуляем значение переменной minV, в которой хранится значение минимального элемента массива val[] 
    maxV_r = 0;
    minV_r = 0;
  }
  
  if (sData_left > threshold){                       // если размах сигнала больше порога срабатывания
    mas_data[0] = 1;
  }
  else{
    mas_data[0] = 0;
  }

  if (sData_right > threshold)
  {
    mas_data[1] = 1;
  }
  else
  {
    mas_data[1] = 0;
  }
  

///////////////////////экг
  int8_t sum = 0;                      // переменная для хранения результата суммирования значений сигнала ЭЭГ
  for (int j = 0; j < num; j++) {          // создаем массив 
  val = analogRead(A2);                // записываем в переменную val оцифрованное значение сигнала с ножки А0 на Arduino.
                                       // val может принимать значение в диапазоне от 0 до 1023, см. http://arduino.ru/Reference/AnalogRead                              
  data[j] = val/8;                     // делим на 8 для того, чтобы диапазон значений val соответствовал размеру элемента массива data[]  
  //Serial.write("A0");                  // записываем в Serial-порт имя поля в программе для визуализации, куда надо выводить сигнал
                                       // всего в этой программе 4 поля, которые имеют имена A0, A1, A2, A3 (сверху вниз, по порядку их расположения в окне программы)
  //Serial.write(map(val, 0, 1023, 0, 255)); // отправляем результат оцифровки в Serial-порт   
    if (data[j] < 2 || data[j] > 120) {// если считанное значение сигнала меньше 2 или больше 120 - считаем, что очень высокий уровень помех в сигнале (не забываем, что значения с А0 разделены на 8)  
      fail = true;                     // в этом случае записываем в переменную fail истинное значение
    }
    delay(2);                          // ждем 2 миллисекунды (1000 миллисекунд = 1 секунда); по-сути, эта величина задает период считывания сигнала со входа А0
    im[j] = 0;                         // обнуляем элементы массива im[]                                      
    sum = sum + data[j];               // прибавляем считанное значение сигнала data[i] к уже накопленной сумме ранее просуммированных значений сигнала
  }
 
 if (!fail) {                          // условие, обозначающее, что значения сигнала не зашкаливают
   for (int j=0; j < num; j++) {                                     
     data[j] = data[j] - sum/num;      // удаляем из записанных в массив data[i] значений сигнала постоянную составляющую (требования работы библиотеки для разложения в спектр fft.h,                    
                                       // для этого из каждого значения массива data[i] вычитаем среднее значение сигнала по всем точкам, накопленным в этом массиве
  }
 // теперь запускаем функцию fix_fft() из библиотеки fft.h для разложения сигнала в спектр
   fix_fft(data, im, 8, 0);            // эта функция осуществляет разложение сигнала в спектр: data - массив с исходными данными, в данном массиве также будет возвращена
                                       // действительная часть результата преобразования Фурье. В массиве im  возвращается мнимая часть результата преобразования Фурье. 
                                       // 8 - обозначает степень числа 2 - задает число спектральных компонент для разложения сигнала (2^8=256 значений)
                                       // 0 - означает, что надо выполнять прямое преобразование Фурье (существует еще обратное преобразование Фурье - задается значением 1)
                                       // подробнее о библиотеке: https://github.com/TJC/arduino/blob/master/sketchbook/libraries/fix_fft/fix_fft.h
                                       // подробнее о преобразовании Фурье: https://habrahabr.ru/post/196374/ 
    bool flag = false;                 // логическая (булева) переменная. ИСТИНА (true) - если значение альфа-ритма выше порогового значения threshold
    specter_old = specter; 
    specter = 0;     
   for (int j = 4; j < 8; j++){            // в массивах со спектральными компонентами ЭЭГ сигнала data[] и im[]
                                       // перебираем частотные компоненты с 4 до 8 - эти спектральные компоненты соответствуют альфа-ритму
     specter +=  sqrt(data[j]*data[j] + im[j]*im[j]); // и суммируем эти спектральные компоненты, которые вычисляем как модуль комплексного числа: https://ru.wikipedia.org/wiki/Комплексное_число#Модуль
   }
   specter = 0.3 * specter + 0.7 * specter_old; // сглаживание сигнала, величину сглаживания выбираем коэффициентами перед переменными specter и specter_old, необходимо чтобы их сумма всегда равнялась единице
  
  if(specter < threshold){         // значение альфа-ритма выше порогового значения threshold
    flag = true;                   // записываем в логическую переменную flag значение ИСТИНА (true)
    }

// нижеследующие условия позволяют плавно снижать обороты мотора, если амплитуда альфа-ритма опускается ниже порогового значения threshold
    if (!flag) {                      // если альфа-ритм не превышал значение порогового значения threshold
      if (sped != 0) {                // и мотор вращается (см. определение переменной sped ниже)
        sped = sped - 25;             // снижаем величину скорости на 25 (можно варьировать это значение, чтобы увеличить/уменьшить скорость вращения)
      }
    }
    if(flag) {                        // если альфа-ритм превысил значение порогового значения threshold
      sped = 200;                     // установим переменную sped, задающую скорость вращения мотора или яркость зажигания светодиода, в 200
      flag = false;                   // и сбросим флаг-признак превышения альфа-ритмом порогового значения threshold
    }
    mas_data[2] = map(sped, 0, 255, 0, 128); 
  }

  else {                               // данный else выполняется, если уровень шума слишком высокий: fail = ИСТИНА
    mas_data[2] = 0;
  }
  fail = false; 
  //Serial.println(mas_data[2]);

  for (int j = 0; j < 3; j++)
  { 
    serial1.write(mas_data[j]);
    Serial.print(mas_data[j]);
    Serial.print("\t");
  }
  serial1.write("\n"); 
  Serial.println(); 
}

void setup() {

  serial1.begin(38400);
  Serial.begin(9600);                // инициализируем Serial-порт на скорости 115200 Кбит/c. 
                                       // такую же скорость надо установить в программе для визуализации

  Timer1.initialize(3000);                   // инициализируем Таймер1, аргументом указываем интервал срабатывания - 3000 микросекунд 
                                             // (1 000 000 микросекунд = 1 сек)
  Timer1.attachInterrupt(sendData);          // как только проходит 3000 микросекунд - наступает прерывание (вызывается функция sendData)

 // заполняем все элементы массива val[] нулями

 for (int k = 0; k < arrSize; k++){
   val_emg_left[k] = 0;
   val_emg_right[k] = 0;
 }
}

void loop() {
}